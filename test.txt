typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);





_Bool 
    test_first(char (*grammar_string)[50], int len);

    test_input_parsing();

    test_set_union();

    test_set_remove();

    test_set_add();

    test_follow(char (*grammar_string)[50], int len);





typedef struct {
    char non_terminal;
    char input_symbol;
    production* p;
    int sub_production_index;
}table_entry;

typedef table_entry* table;

table create_parsing_table(production** grammar, ssize_t num_productions);
table_entry* table_get_entry(table t, char non_terminal, char input_symbol);
void print_table(table t);






struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);



set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);




void predictive_parse(const char* string, table parsing_table, production** grammar);

char** get_grammar_from_user(int num_productions){
    char** grammar = malloc(sizeof(int *) * num_productions);
    for(int i=0; i < num_productions; ++i){
        grammar[i] = malloc(sizeof(char) * 100);
        scanf("%s", grammar[i]);
    }
    return grammar;
}

int get_productions_count(){
    int num_productions;
    scanf("%d", &num_productions);
    return num_productions;
}

void run_tests(){
    char grammar_string[5][50] = {"E->TA", "A->+TA|.", "T->FB", "B->*FB|.", "F->(E)|i"};





    production** p = malloc(sizeof(production) * 5);
    for(int i=0; i<5; ++i){
        p[i] = parse_production_from_string(grammar_string[i]);
    }
    table t = create_parsing_table(p, 5);
    predictive_parse("i+i*i", t, p);
    predictive_parse("(i)", t, p);

}

int main() {
    printf("Predictive Parser\n");
    printf("Enter number of productions:");
    const int num_productions = get_productions_count();
    char **grammar = get_grammar_from_user(num_productions);
    production** p = get_production_from_string_collection(grammar, num_productions);




    table t = create_parsing_table(p, 5);
    while(
             ){
        printf("Enter string:");
        char str[100];
        scanf("%s", str);
        predictive_parse(str, t, p);
        char c;
        scanf("%c", &c);
        if(c == 'n') break;
    }
    return 0;
}






typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);



void copy_string(char*,const char*);
int num_occurrence(const char*, char);


void print_production(production *p){
    printf("%c->", p->left);
    int i;
    for(i=0; i<p->right->size - 1; ++i){
        printf("%s|",p->right->body[i].production);
    }
    printf("%s\n",p->right->body[i].production);
}

void get_production_as_string(char *string, production *p){
    sprintf(string, "%c->", p->left);
    int i;
    for(i=0; i<p->right->size - 1; ++i){
        sprintf(strchr(string, '\0'),"%s|",p->right->body[i].production);
    }
    sprintf(strchr(string, '\0'),"%s",p->right->body[i].production);
}

production_body_list* parse_production_body_from_string(const char* start_of_production_body){
    char backup[100];
    copy_string(backup, start_of_production_body);

    production_body_list* p = malloc((sizeof(production_body_list)));
    p->size = num_occurrence(start_of_production_body, '|') + 1;
    p->body = malloc(sizeof(production_body) * p->size);

    for(int i=0; i<p->size; ++i) {
        p->body[i].production = malloc(sizeof(char) * 10);
    }

    char* token;

    token = strtok(backup, "|");
    copy_string(p->body[0].production, token);
    for(int i=1; token && i<p->size; ++i){
        token = strtok(
                          , "|");
        copy_string(p->body[i].production, token);
    }
    return p;
}

production* parse_production_from_string(const char* string){

    production* p = malloc(sizeof(production));

    p -> left = string[0];
    production_body_list* b = parse_production_body_from_string(string+3);
    p -> right = b;
    return p;
}


    is_terminal(char c){
    return !
           c
                     ;
}


    is_nonterminal(char c){
    return 
          c
                    ;
}

production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions){
    for(ssize_t i=0; i<num_productions; ++i){
        if(grammar[i]->left == non_terminal) return grammar[i];
    }
    return 
              ;
}

production **get_production_from_string_collection(char **grammar, int num_productions) {

    production** p = malloc(sizeof(production) * num_productions);

    for(int i=0; i<num_productions; ++i){
        p[i] = parse_production_from_string(grammar[i]);
    }
    return p;
}





typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);



void copy_string(char*,const char*);
int num_occurrence(const char*, char);


void copy_string(char* destination,const char* source){
    strncpy(destination, source, strlen(source));
    destination[strlen(source)] = '\0';
}

int num_occurrence(const char* string, char symbol){
    int num = 0;
    for(int i=0; i<strlen(string); ++i){
        if(string[i] == symbol) ++num;
    }
    return num;
}



void copy_string(char*,const char*);
int num_occurrence(const char*, char);








typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


    test_first(char (*grammar_string)[50], int len);

    test_input_parsing();

    test_set_union();

    test_set_remove();

    test_set_add();

    test_follow(char (*grammar_string)[50], int len);






struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);



set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);




set FOLLOW(char symbol, production** grammar, ssize_t num_productions);





    test_set_add(){
    set s = create_set(5);
    set_add(s, 'A');
    set_add(s, 'B');
    set_add(s, 'C');
    set_add(s, 'A');
    print_set(s);
}


    test_set_remove(){
    set s = create_set(5);
    set_add(s, 'A');
    set_add(s, 'B');
    set_add(s, 'C');
    set_add(s, 'D');
    set_add(s, 'E');
    set_remove(s, 'C');
    print_set(s);
}


    test_set_union(){
    set a,b;
    a = create_set(4);
    b = create_set(5);
    set_add(a, 'A');
    set_add(a, 'B');
    set_add(b, 'C');
    set_add(b, 'D');
    set_union(a, b);
    print_set(a);
};


    test_input_parsing(){
    char test_cases[3][50] = {"A->bB|cD|D", "B->.", "D->x|y|z|w"};
    production** p = malloc(sizeof(production) * 3);
    char string[100];
    for(int i=0; i<3; ++i){
        p[i] = parse_production_from_string(test_cases[i]);
    }
    for(int i=0; i<3; ++i){
        get_production_as_string(string, p[i]);
        if(strcmp(string, test_cases[i]) == 0) printf("\tTest case {%d} : Passed ✔\n", i+1);
        else {
            printf("\tTest case {%d} : Failed ✖\n", i+1);
            printf("\t\tExpected = %s\n\t\tFound = %s\n", test_cases[i], string);
        }
    }
    return 
              ;
}


    test_first(char (*grammar_string)[50], int len){
    production** p = malloc(sizeof(production) * len);
    for(int i=0; i<len; ++i){
        p[i] = parse_production_from_string(grammar_string[i]);
    }
    for(int i=0; i<len; ++i){
        const char symbol = p[i]->left;
        set first = FIRST(symbol, p, len);
        printf("FIRST(%c) = ", symbol);
        print_set(first);
    }
    return 
              ;
}


    test_follow(char (*grammar_string)[50], int len){
    production** p = malloc(sizeof(production) * len);
    for(int i=0; i<len; ++i){
        p[i] = parse_production_from_string(grammar_string[i]);
    }
    for(int i=0; i<len; ++i){
        const char symbol = p[i]->left;
        set follow = FOLLOW(symbol, p, len);
        printf("FOLLOW(%c) = ", symbol);
        print_set(follow);
    }


    return 
              ;
}








typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


    test_first(char (*grammar_string)[50], int len);

    test_input_parsing();

    test_set_union();

    test_set_remove();

    test_set_add();

    test_follow(char (*grammar_string)[50], int len);








struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);






typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);
set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);





_Bool 
    is_epsilon_present(production* p){
    ssize_t len = p->right->size;
    for(ssize_t i=0; i<len; ++i) {
        if(strcmp(p->right->body[i].production, ".") == 0) return 
                                                                     ;
    }
    return 
               ;
}

set FIRST(char symbol, production** grammar, ssize_t num_productions){
    set first = create_set(10);
    if(is_terminal(symbol)){
        set_add(first, symbol);
        return first;
    }
    else {


        production *p = get_production_of_nonterminal(symbol, grammar, num_productions);

        if (is_epsilon_present(p)) {
            set_add(first, '.');
        }


        for(ssize_t i=0; i<p->right->size; ++i) {
            
                add_epsilon = 
                                  ;
            const production_body sub_production = p->right->body[i];
            for(int j=0; j<strlen(sub_production.production); ++j){
                set _first = FIRST(sub_production.production[j], grammar, num_productions);
                if(set_contains(_first, '.') == -1) {
                    add_epsilon = 
                                      ;
                    break;
                }
            }
            if(add_epsilon) set_add(first, '.');
        }


        for(ssize_t i=0; i<p->right->size; ++i){
            const production_body sub_production = p->right->body[i];
            const char first_char = sub_production.production[0];
            set _first = FIRST(first_char, grammar, num_productions);
            if(set_contains(_first, '.') != -1 && strlen(sub_production.production) >=2){
                set_remove(_first, '.');
                set_union(_first, FIRST(sub_production.production[1], grammar, num_productions));
                set_union(first, _first);
            }
            else{

                set_union(first, _first);
            }
        }
    }
    return first;
}

set FIRST_string(char *string, production** grammar, ssize_t num_productions){
    const int len = strlen(string);
    set first = create_set(20);
    
        add_epsilon = 
                          ;
    for(int i=0; i<len; ++i){
        const char symbol = string[i];
        set _first = FIRST(symbol, grammar, num_productions);
        
            cond = set_contains(_first, '.') == -1;
        set_remove(_first, '.');
        set_union(first, _first);
        if(cond){

            add_epsilon = 
                              ;
            break;
        }
    }
    if(add_epsilon) set_add(first, '.');
    return first;
}








struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);






typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);
set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);





struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);







void set_union(set destination, set source){
    for(ssize_t i=0; i<source->index; ++i){
        set_add(destination, source->elements[i]);
    }
}


set create_set(ssize_t length){
    set s = malloc(sizeof(struct set_s));
    s->elements = malloc(sizeof(char) * length);
    s->length = length;
    s->index = 0;
    return s;
}


void set_add(set s, char element){
    if(set_contains(s, element) != -1) return;
    s->elements[s->index++] = element;
}


set get_set_from_array(char *array, ssize_t len){
    set s = malloc(sizeof(set));
    s->length = len;
    s->elements = malloc(sizeof(char) * len);
    for(int i=0; i<s->length; ++i) s->elements[i] = array[i];
    return s;
}

int set_contains(set s, char element){
    for(ssize_t i=0; i<s->index; ++i){
        if(s->elements[i] == element) return i;
    }
    return -1;
}


    is_set_singleton(set s){
    return s->index == 1 ? 
                              : 
                                     ;
}

void set_remove(set s, char element){
    int pos = set_contains(s, element);
    if(pos == -1) return;
    for(ssize_t i=pos; i<s->index-1; ++i){
        s->elements[i] = s->elements[i+1];
    }
    s->length = s->length -1;
    s->index = s->index -1;
}

void print_set(set s){
    printf("{");
    for(ssize_t i=0; i<s->index-1; ++i) {
        printf("%c, ",s->elements[i]);
    }
    printf("%c}\n", s->elements[s->index - 1]);
}

int get_set_size(set s){
    return s->index;
}

void set_dealloc(set s){
    free(s->elements);
    free(s);
}





struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);








struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);






typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);

set FOLLOW(char symbol, production** grammar, ssize_t num_productions);



set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);


set FOLLOW(char symbol, production** grammar, ssize_t num_productions){




    set follow = create_set(10);
    char S = grammar[0]->left;
    if(symbol == S){
        set_add(follow, '$');
    }
   for(ssize_t i=0; i<num_productions; ++i){
       production* p = grammar[i];
       for(ssize_t j=0; j<p->right->size; ++j){
           production_body sub_production = p->right->body[j];
           const int strlen_production = strlen(sub_production.production);
           for(int k=0; k<strlen_production; ++k){
               char check_char= sub_production.production[k];
               if(sub_production.production[k] == symbol){
                  if(k == strlen_production-1){

                      if(p->left != symbol) {
                          set _follow = FOLLOW(p->left, grammar, num_productions);
                          set_union(follow, _follow);
                      }
                  }
                  else{

                      
                          set_contains_epsilon = 
                                                     ;
                      int start = k+1;
                      while(set_contains_epsilon && start < strlen_production){
                          set _first = FIRST(sub_production.production[start], grammar, num_productions);
                          set_contains_epsilon = set_contains(_first, '.') != -1;
                          set_remove(_first, '.');
                          set_union(follow, _first);
                          if(set_contains_epsilon ){

                              set _follow = FOLLOW(p->left, grammar, num_productions);
                              set_union(follow, _follow);
                              start++;
                          }
                      }
                  }
               }
           }
       }
   }
   return follow;
}








struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);






typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);

set FOLLOW(char symbol, production** grammar, ssize_t num_productions);








typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


typedef struct {
    char non_terminal;
    char input_symbol;
    production* p;
    int sub_production_index;
}table_entry;

typedef table_entry* table;

table create_parsing_table(production** grammar, ssize_t num_productions);
table_entry* table_get_entry(table t, char non_terminal, char input_symbol);
void print_table(table t);






struct set_s{
    ssize_t length;
    char *elements;
    int index;
};

typedef struct set_s *set;

set create_set(ssize_t);
void set_add(set, char);
set get_set_from_array(char*, ssize_t);
void set_union(set, set);
void set_remove(set, char);
int set_contains(set, char);

    is_set_singleton(set s);
void print_set(set);
int get_set_size(set s);
void set_dealloc(set s);



set FIRST(char, production**, ssize_t);
set FIRST_string(char *string, production** grammar, ssize_t num_productions);




set FOLLOW(char symbol, production** grammar, ssize_t num_productions);


int table_size = 0;


void print_table(table t){
    int c = 0;
    for(int i=0; i<table_size; ++i){
        if(t[i].p != 
                        ){
            c++;
            printf("TABLE(%c,%c) =", t[i].non_terminal, t[i].input_symbol);
            const int sub_index = t[i].sub_production_index;
            printf("%c->%s\n", t[i].p->left, t[i].p->right->body[sub_index].production);
        }
    }
    printf("Total table size = %d\n", c);
}

void empty(table t){
    for(int i=0; i<table_size; ++i){
        t[i].p = 
                    ;
    }
}

table_entry* table_get_entry(table t, char non_terminal, char input_symbol){
    for(int i=0; i<table_size; ++i){
        if(t[i].input_symbol == input_symbol && t[i].non_terminal == non_terminal){
            return &t[i];
        }
    }
    return 
              ;
}

void table_add(table t, char non_terminal, char input_symbol, production *p, int sub_production_index){
    if(input_symbol == '.') return;
    static int i = 0;
    t[i].non_terminal = non_terminal;
    t[i].input_symbol = input_symbol;
    t[i].p = p;
    t[i].sub_production_index = sub_production_index;
    i = i+1;
}

set get_terminals(production** grammar, ssize_t num_productions){
    set terminals = create_set(10);
    for(ssize_t i=0; i<num_productions; ++i){
        production *p = grammar[i];
        for(ssize_t j=0; j<p->right->size; ++j){
            char *sub_production = p->right->body[j].production;
            for(int k=0; k< strlen(sub_production); ++k){
                if(is_terminal(sub_production[k])) set_add(terminals, sub_production[k]);
            }
        }
    }
    return terminals;
}

int get_number_of_terminals(production** grammar, ssize_t num_productions){
    set terminals = get_terminals(grammar, num_productions);
    const int num_terminals = get_set_size(terminals);
    set_dealloc(terminals);
    return num_terminals;
}

table create_parsing_table(production** grammar, ssize_t num_productions){
    const int num_non_terminals = num_productions;
    const int num_terminals = get_number_of_terminals(grammar, num_productions);
    const int pt_size = num_non_terminals * num_terminals;
    table_size = pt_size;
    table entries = malloc(sizeof(table_entry) * pt_size);
    empty(entries);
    for(ssize_t i=0; i<num_productions; ++i){
        production *p = grammar[i];
        const int num_sub_productions = p->right->size;
        for(ssize_t k=0; k<num_sub_productions; ++k){
            production_body sub_production = p->right->body[k];

            set first = FIRST_string(sub_production.production, grammar, num_productions);


            for(ssize_t j=0; j<first->index; ++j){
                const char element = first->elements[j];
                if(is_terminal(element)){
                    table_add(entries, p->left, element, p, k);
                }
            }


            if(set_contains(first, '.') != -1){

                set follow = FOLLOW(p->left, grammar, num_productions);
                for(ssize_t j=0; j<follow->index; ++j){
                    const char element = follow->elements[j];
                    if(is_terminal(element)){
                        table_add(entries, p->left, element, p, k);
                    }
                }
            }

        }
    }
    return entries;
}








typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


typedef struct {
    char non_terminal;
    char input_symbol;
    production* p;
    int sub_production_index;
}table_entry;

typedef table_entry* table;

table create_parsing_table(production** grammar, ssize_t num_productions);
table_entry* table_get_entry(table t, char non_terminal, char input_symbol);
void print_table(table t);











typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


typedef struct {
    char non_terminal;
    char input_symbol;
    production* p;
    int sub_production_index;
}table_entry;

typedef table_entry* table;

table create_parsing_table(production** grammar, ssize_t num_productions);
table_entry* table_get_entry(table t, char non_terminal, char input_symbol);
void print_table(table t);

void predictive_parse(const char* string, table parsing_table, production** grammar);





struct s_stack;

typedef struct s_stack* stack;

stack create_stack();

void push(stack s, char element);

char pop(stack s);

char stack_top(stack s);

void dealloc_stack(stack s);

void error(stack s){
    printf("Error in parsing\n");
    dealloc_stack(s);
}

void predictive_parse(const char* string, table parsing_table, production** grammar){
    const int buffer_length = strlen(string) + 1;
    char *input_buffer = malloc(sizeof(char) * buffer_length);
    strncpy(input_buffer, string, strlen(string));
    char *current_symbol = input_buffer;

    input_buffer[buffer_length-1] = '$';


    stack s = create_stack();
    push(s,'$');
    const char starting_symbol = grammar[0]->left;
    push(s, starting_symbol);
    printf("Attempting follow productions:\n");
    while(stack_top(s) != '$'){

        const char s_top = stack_top(s);
        if(s_top == *current_symbol){
            pop(s);
            current_symbol++;
        }
        else if(is_terminal(s_top)){
            error(s);
            return;
        }
        else if(table_get_entry(parsing_table, s_top, *current_symbol) == 
                                                                             ){
            error(s);
            return;
        }
        else{
            table_entry* t = table_get_entry(parsing_table, s_top, *current_symbol);
            production_body sub_production = t->p->right->body[t->sub_production_index];
            const int strlen_sub_production = strlen(sub_production.production);
            pop(s);
            printf("\t%c->%s\n",t->p->left, sub_production.production);
            for(int i=strlen_sub_production-1; i>=0; --i){
                push(s, sub_production.production[i]);
            }
        }
    }
    printf("Parsing is successful!!\n");

}











typedef struct{
    char* production;
}production_body;

typedef struct{
    ssize_t size;
    production_body* body;
}production_body_list;

typedef struct{
    char left;
    production_body_list *right;
}production;

void print_production(production*);
void get_production_as_string(char*, production*);
production* parse_production_from_string(const char*);
production* get_production_of_nonterminal(char non_terminal, production **grammar, ssize_t num_productions);

    is_terminal(char c);

    is_nonterminal(char c);
production** get_production_from_string_collection(char **grammar, int num_productions);


typedef struct {
    char non_terminal;
    char input_symbol;
    production* p;
    int sub_production_index;
}table_entry;

typedef table_entry* table;

table create_parsing_table(production** grammar, ssize_t num_productions);
table_entry* table_get_entry(table t, char non_terminal, char input_symbol);
void print_table(table t);

void predictive_parse(const char* string, table parsing_table, production** grammar);



struct s_stack;

typedef struct s_stack* stack;

stack create_stack();

void push(stack s, char element);

char pop(stack s);

char stack_top(stack s);

void dealloc_stack(stack s);


struct s_stack{
    char elements[100];
    int top;
};

stack create_stack() {
    stack s = malloc(sizeof(struct s_stack ));
    s->top = -1;
    return s;
}

void push(stack s, const char element) {
    if(element == '.') return;
    s->top++;
    s->elements[s->top] = element;
}

char pop(stack s) {
    const char element = s->elements[s->top];
    s->top--;
    return element;
}

char stack_top(stack s) {
    return s->elements[s->top];
}

void dealloc_stack(stack s) {
    free(s);
}



struct s_stack;

typedef struct s_stack* stack;

stack create_stack();

void push(stack s, char element);

char pop(stack s);

char stack_top(stack s);

void dealloc_stack(stack s);
